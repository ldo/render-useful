#!/usr/bin/python3
#+
# This script handles conversion of .blend files between
# the various available compressed formats, as well as
# no compression at all.
#
# Copyright 2021 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import enum
import struct
import getopt
import gzip
try :
    import zstd # get from <https://github.com/sergey-dryabzhinsky/python-zstd>
except ImportError :
    zstd = None
#end try

#+
# Compression support
#-

blender_sig = b"BLENDER"
  # (decompressed) file must begin with this

class ZSTD :
    "various magic strings associated with the Zstandard compression format."
    COMPR_FRAME_SIG = b"\x28\xB5\x2F\xFD"
    SKIPPABLE_FRAME_SIG = b"\x5E\x2A\x4D\x18"
      # seek-table spec:
      # <https://github.com/facebook/zstd/blob/master/contrib/seekable_format/zstd_seekable_compression_format.md>
    SEEK_MAGIC = b"\xb1\xea\x92\x8f"
      # comes at end of seek table, so it can be found searching backwards
#end ZSTD

class UncompressedWrapper :

    def __init__(self, fileobj, writing) :
        self.fileobj = fileobj
        self.writing = writing
        if writing :
            self.read = None
            self.tell = None
            self.write = fileobj.write
            self.flush = fileobj.flush
        else :
            self.read = fileobj.read
            self.tell = fileobj.tell
            self.write = None
            self.flush = None
        #end if
    #end __init__

    def close(self) :
        self.fileobj.close()
        self.fileobj = None
    #end close

#end UncompressedWrapper

class GzipWrapper :

    def __init__(self, fileobj, writing) :
        self.fileobj = fileobj
        self.writing = writing
        wrap = gzip.GzipFile(mode = ("r", "w")[writing], fileobj = fileobj)
        self.wrap = wrap
        if writing :
            self.read = None
            self.tell = None
            self.write = wrap.write
            self.flush = wrap.flush
        else :
            self.read = wrap.read
            self.tell = wrap.tell
            self.write = None
            self.flush = None
        #end if
    #end __init__

    def close(self) :
        self.wrap.close()
        self.fileobj.close() # no option for Gzip to do this for me
        self.wrap = None
        self.fileobj = None
    #end close

#end GzipWrapper

if zstd != None :

    class ZStdWrapper :

        def __init__(self, fileobj, writing) :
            self.fileobj = fileobj
            if writing :
                self.read = None
                self.tell = None
                buf = b""
                maxbuf = 32768
                # Seek table is required for compatibility with Blender 3.0, to
                # avoid “unsupported file format” error.
                # It appears this requirement is considered a bug <https://developer.blender.org/T93858>
                # and will be relaxed in later versions. But I create it anyway.
                seek_table = []

                def write_compressed(data) :
                    # writes out a compressed frame, and records
                    # a seek-table entry for it.
                    compressed = zstd.compress(data)
                    seek_table.append((len(compressed), len(data)))
                    fileobj.write(compressed)
                #end write_compressed

                def write(data) :
                    nonlocal buf
                    buf += data
                    while len(buf) >= maxbuf :
                        write_compressed(buf[:maxbuf])
                        buf = buf[maxbuf:]
                    #end while
                #end write

                def flush() :
                    nonlocal buf
                    if len(buf) != 0 :
                        write_compressed(buf)
                        buf = b""
                    #end if
                    fileobj.flush()
                #end flush

                def close() :
                    self.flush()
                    fileobj.write(ZSTD.SKIPPABLE_FRAME_SIG)
                    fileobj.write(struct.pack("<L", len(seek_table) * 8 + 9))
                    for clen, dlen in seek_table :
                        fileobj.write(struct.pack("<LL", clen, dlen))
                    #end for
                    fileobj.write(struct.pack("<L", len(seek_table)))
                    fileobj.write(b"\x00") # no checksums (bit 7)
                    fileobj.write(ZSTD.SEEK_MAGIC)
                    fileobj.close()
                    self.fileobj = None
                #end close

                self.write = write
                self.flush = flush
                self.close = close
            else :
                # actually, tell method is not used in this program
                cbuf = b""
                dbuf = b""
                doffset = 0
                eof = False

                def read(nrbytes) :
                    nonlocal cbuf, dbuf, doffset, eof
                    result = b""
                    while True :
                        if len(dbuf) >= nrbytes :
                            doffset += nrbytes
                            result += dbuf[:nrbytes]
                            dbuf = dbuf[nrbytes:]
                            break
                        #end if
                        if len(dbuf) != 0 :
                            doffset += len(dbuf)
                            result += dbuf
                            dbuf = b""
                        #end if
                        if len(cbuf) == 0 and eof :
                            break
                        if (
                                not eof
                            and
                                (
                                    len(cbuf) < len(COMPRESSION.ZSTD.sig)
                                or
                                    cbuf.find(COMPRESSION.ZSTD.sig, len(COMPRESSION.ZSTD.sig)) < 0
                                )
                        ) :
                            cmore = fileobj.read(32768)
                            if len(cmore) != 0 :
                                cbuf += cmore
                            else :
                                eof = True
                            #end if
                        #end if
                        assert cbuf.startswith(COMPRESSION.ZSTD.sig)
                        frame_end = cbuf.find(COMPRESSION.ZSTD.sig, len(COMPRESSION.ZSTD.sig))
                        if eof and frame_end < 0 :
                            frame_end = len(cbuf)
                        #end if
                        if frame_end >= 0 :
                            dbuf += zstd.decompress(cbuf[:frame_end])
                            cbuf = cbuf[frame_end:]
                        #end if
                    #end while
                    return result
                #end read

                def tell() :
                    return doffset
                #end tell

                def close() :
                    fileobj.close()
                #end close

                self.read = read
                self.tell = tell
                self.write = None
                self.flush = None
                self.close = close
            #end if
        #end def

    #end ZStdWrapper

else :
    ZStdWrapper = None
#end if

class COMPRESSION(enum.Enum) :
    "compression formats for .blend files."
    NONE = ("none", None, UncompressedWrapper)
    GZIP = ("gzip", b"\x1F\x8B", GzipWrapper)
    ZSTD = ("zstd", ZSTD.COMPR_FRAME_SIG, ZStdWrapper) # Blender 3.0 and later

    @property
    def name(self) :
        return \
            self.value[0]
    #end name

    @property
    def sig(self) :
        "file using this format must begin with this bytestring."
        return \
            self.value[1]
    #end sig

    @property
    def wrap(self) :
        "wrapper class/function implementing this compression format."
        return \
            self.value[2]
    #end wrap

#end COMPRESSION

#+
# Mainline
#-

io_blocksize = 8192
out_compression = COMPRESSION.NONE
show_info = False
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ("compression=", "info"),
  )
for keyword, value in opts :
    if keyword == "--compression" :
        out_compression = list(c for c in COMPRESSION if c.name == value.lower())
        if len(out_compression) > 0 :
            out_compression = out_compression[0]
        else :
            raise getopt.GetoptError("unrecognized compression format %s" % value)
        #end if
    elif keyword == "--info" :
        show_info = True
    #end if
#end for
if len(args) not in (1, 2) :
    raise getopt.GetoptError("usage: %s «inblendfile» [«outblendfile»]" % sys.argv[0])
#end if
infilename = args[0]
if len(args) > 1 :
    outfilename = args[1]
else :
    outfilename = None
#end if

infile = open(infilename, "rb")
try_formats = iter \
  (
    sorted
      (
        (c for c in list(COMPRESSION) if c.sig != None),
        key = lambda c : len(c.sig)
      )
  )
sig = b""
while True :
    in_compression = next(try_formats, None)
    if in_compression == None :
        # not compressed
        in_compression = COMPRESSION.NONE
        infile.seek(0)
        infile = UncompressedWrapper(infile, False)
        break
    #end if
    if len(in_compression.sig) != len(sig) :
        sig += infile.read(len(in_compression.sig) - len(sig))
    #end if
    if sig == in_compression.sig :
        if in_compression.wrap == None :
            raise RuntimeError \
              (
                "file is %s-compressed, but decompression wrapper is not available" % in_compression.name
              )
        #end if
        infile.seek(0)
        infile = in_compression.wrap(infile, False)
        break
    #end if
#end while
if infile.read(len(blender_sig)) != blender_sig :
    raise RuntimeError("uncompressed file does not begin with %s" % repr(blender_sig))
#end if
if show_info :
    sys.stderr.write("%s uses “%s” compression\n" % (infilename, in_compression.name))
#end if
if outfilename != None :
    if out_compression.wrap == None :
        raise RuntimeError \
          (
            "%s compression requested, but compression wrapper is not available" % out_compression.name
          )
    #end if
    outfile = out_compression.wrap(open(outfilename, "wb"), True)
    # infile.seek(0) # zstd doesn’t allow seeking backwards
    outfile.write(blender_sig) # instead, write out what I have already read
    while True :
        data = infile.read(io_blocksize)
        if len(data) == 0 :
            break
        outfile.write(data)
    #end while
    outfile.close()
#end if
infile.close()
