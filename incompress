#!/usr/bin/python3
#+
# This script handles conversion of .blend files between
# the various available compressed formats, as well as
# no compression at all.
#
# Copyright 2021 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import enum
import struct
import getopt
import gzip
try :
    import zstd # get from <https://github.com/sergey-dryabzhinsky/python-zstd>
except ImportError :
    zstd = None
#end try

#+
# Compression support
#-

blender_sig = b"BLENDER"
  # (decompressed) file must begin with this

class ZSTD :
    "various magic strings associated with the Zstandard compression format."
    COMPR_FRAME_SIG = b"\x28\xB5\x2F\xFD"
    SKIPPABLE_FRAME_SIG = b"\x5E\x2A\x4D\x18"
      # seek-table spec:
      # <https://github.com/facebook/zstd/blob/master/contrib/seekable_format/zstd_seekable_compression_format.md>
    SEEK_MAGIC = b"\xb1\xea\x92\x8f"
      # comes at end of seek table, so it can be found searching backwards
#end ZSTD

class UncompressedWrapper :

    def __init__(self, fileobj, writing) :
        self.fileobj = fileobj
        self.writing = writing
        if writing :
            self.read = None
            self.tell = None
            self.write = fileobj.write
            self.flush = fileobj.flush
        else :
            self.read = fileobj.read
            self.tell = fileobj.tell
            self.write = None
            self.flush = None
        #end if
    #end __init__

    def close(self) :
        self.fileobj.close()
        self.fileobj = None
    #end close

#end UncompressedWrapper

class GzipWrapper :

    def __init__(self, fileobj, writing) :
        self.fileobj = fileobj
        self.writing = writing
        wrap = gzip.GzipFile(mode = ("r", "w")[writing], fileobj = fileobj)
        self.wrap = wrap
        if writing :
            self.read = None
            self.tell = None
            self.write = wrap.write
            self.flush = wrap.flush
        else :
            self.read = wrap.read
            self.tell = wrap.tell
            self.write = None
            self.flush = None
        #end if
    #end __init__

    def close(self) :
        self.wrap.close()
        self.fileobj.close() # no option for Gzip to do this for me
        self.wrap = None
        self.fileobj = None
    #end close

#end GzipWrapper

if zstd != None :

    class ZStdWrapper :

        def __init__(self, fileobj, writing) :
            self.fileobj = fileobj
            if writing :
                self.read = None
                self.tell = None
                buf = b""
                maxbuf = 32768
                  # Some frame size roughly similar to what I see in files
                  # created by Blender
                seek_table = []
                  # Seek table is required for compatibility with Blender 3.0, to
                  # avoid “unsupported file format” error.
                  # It appears this requirement is considered a bug <https://developer.blender.org/T93858>
                  # and will be relaxed in later versions. But I create it anyway.

                def write_compressed(data) :
                    # writes out a compressed frame, and records
                    # a seek-table entry for it.
                    compressed = zstd.compress(data)
                    seek_table.append((len(compressed), len(data)))
                    fileobj.write(compressed)
                #end write_compressed

                def write(data) :
                    nonlocal buf
                    buf += data
                    while len(buf) >= maxbuf :
                        write_compressed(buf[:maxbuf])
                        buf = buf[maxbuf:]
                    #end while
                #end write

                def flush() :
                    nonlocal buf
                    if len(buf) != 0 :
                        write_compressed(buf)
                        buf = b""
                    #end if
                    fileobj.flush()
                #end flush

                def close() :
                    self.flush()
                    fileobj.write(ZSTD.SKIPPABLE_FRAME_SIG)
                    fileobj.write(struct.pack("<L", len(seek_table) * 8 + 9))
                    for clen, dlen in seek_table :
                        fileobj.write(struct.pack("<LL", clen, dlen))
                    #end for
                    fileobj.write(struct.pack("<L", len(seek_table)))
                    fileobj.write(b"\x00") # no checksums (bit 7)
                    fileobj.write(ZSTD.SEEK_MAGIC)
                    fileobj.close()
                    self.fileobj = None
                    self.write = self.flush = self.close = None # break any circularities
                #end close

                self.write = write
                self.flush = flush
                self.close = close
            else :
                # actually, tell method is not used in this program
                dbuf = b""
                doffset = 0
                eof = False

                def read(nrbytes) :
                    nonlocal dbuf, doffset, eof
                    result = b""
                    while True :
                        if len(dbuf) >= nrbytes :
                            doffset += nrbytes
                            result += dbuf[:nrbytes]
                            dbuf = dbuf[nrbytes:]
                            break
                        #end if
                        if len(dbuf) != 0 :
                            doffset += len(dbuf)
                            result += dbuf
                            dbuf = b""
                        #end if
                        if eof :
                            break
                        coffset = fileobj.tell()
                        sig = fileobj.read(4)
                        if len(sig) == 0 :
                            eof = True
                            break
                        #end if
                        if sig == ZSTD.COMPR_FRAME_SIG :
                            # collect the complete compressed frame. This is slightly
                            # tricky, since I have to parse bits of it to work out the
                            # total length.
                            cbuf = sig
                            header_desc = fileobj.read(1)
                            cbuf += header_desc
                            header_desc = header_desc[0]
                            fcs_field_size = 1 << (header_desc >> 6 & 3)
                            single_segment = header_desc >> 5 & 1 != 0
                            if fcs_field_size == 1 and not single_segment :
                                fcs_field_size = 0
                            #end if
                            has_content_checksum = header_desc >> 2 & 1 != 0
                            dictionary_id_size = header_desc & 3
                            if dictionary_id_size != 0 :
                                dictionary_id_size = 1 << dictionary_id_size - 1
                            #end if
                            if not single_segment :
                                cbuf += fileobj.read(1) # window_desc
                            #end if
                            if dictionary_id_size != 0 :
                                cbuf += fileobj.read(dictionary_id_size) # dictionary ID
                            #end if
                            if fcs_field_size != 0 :
                                cbuf += fileobj.read(fcs_field_size) # frame size field
                            #end if
                            while True :
                                block_header = fileobj.read(3)
                                cbuf += block_header
                                block_header = block_header[0] | block_header[1] << 8 | block_header[2] << 16
                                last_block = block_header & 1 != 0
                                block_type = block_header >> 1 & 3
                                block_size = block_header >> 3
                                content_size = \
                                    {
                                        0 : block_size,
                                        1 : 1, # RLE block,
                                        2 : block_size,
                                    }[block_type]
                                cbuf += fileobj.read(content_size)
                                if last_block :
                                    break
                            #end while
                            if has_content_checksum :
                                cbuf += fileobj.read(4)
                            #end if
                            dbuf += zstd.decompress(cbuf)
                        elif sig == ZSTD.SKIPPABLE_FRAME_SIG :
                            frame_len, = struct.unpack("<L", fileobj.read(4))
                            fileobj.seek(coffset + frame_len + 8)
                        else :
                            raise RuntimeError \
                              (
                                "unrecognizable signature %s at offset %#0.8x" % (repr(sig), coffset)
                              )
                        #end if
                    #end while
                    return result
                #end read

                def tell() :
                    return doffset
                #end tell

                def close() :
                    fileobj.close()
                    self.read = self.tell = self.close = None # break any circularities
                #end close

                self.read = read
                self.tell = tell
                self.write = None
                self.flush = None
                self.close = close
            #end if
        #end def

    #end ZStdWrapper

else :
    ZStdWrapper = None
#end if

class COMPRESSION(enum.Enum) :
    "compression formats for .blend files."
    NONE = ("none", None, UncompressedWrapper)
    GZIP = ("gzip", b"\x1F\x8B", GzipWrapper)
    ZSTD = ("zstd", ZSTD.COMPR_FRAME_SIG, ZStdWrapper) # Blender 3.0 and later

    @property
    def name(self) :
        return \
            self.value[0]
    #end name

    @property
    def sig(self) :
        "file using this format must begin with this bytestring."
        return \
            self.value[1]
    #end sig

    @property
    def wrap(self) :
        "wrapper class/function implementing this compression format."
        return \
            self.value[2]
    #end wrap

#end COMPRESSION

#+
# Mainline
#-

io_blocksize = 8192
out_compression = COMPRESSION.NONE
show_info = False
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ("compression=", "info"),
  )
for keyword, value in opts :
    if keyword == "--compression" :
        out_compression = list(c for c in COMPRESSION if c.name == value.lower())
        if len(out_compression) > 0 :
            out_compression = out_compression[0]
        else :
            raise getopt.GetoptError("unrecognized compression format %s" % value)
        #end if
    elif keyword == "--info" :
        show_info = True
    #end if
#end for
if len(args) not in (1, 2) :
    raise getopt.GetoptError("usage: %s «inblendfile» [«outblendfile»]" % sys.argv[0])
#end if
infilename = args[0]
if len(args) > 1 :
    outfilename = args[1]
else :
    outfilename = None
#end if

infile = open(infilename, "rb")
try_formats = iter \
  (
    sorted
      (
        (c for c in list(COMPRESSION) if c.sig != None),
        key = lambda c : len(c.sig)
      )
  )
sig = b""
while True :
    in_compression = next(try_formats, None)
    if in_compression == None :
        # not compressed
        in_compression = COMPRESSION.NONE
        infile.seek(0)
        infile = UncompressedWrapper(infile, False)
        break
    #end if
    if len(in_compression.sig) != len(sig) :
        sig += infile.read(len(in_compression.sig) - len(sig))
    #end if
    if sig == in_compression.sig :
        if in_compression.wrap == None :
            raise RuntimeError \
              (
                "file is %s-compressed, but decompression wrapper is not available" % in_compression.name
              )
        #end if
        infile.seek(0)
        infile = in_compression.wrap(infile, False)
        break
    #end if
#end while
if infile.read(len(blender_sig)) != blender_sig :
    raise RuntimeError("uncompressed file does not begin with %s" % repr(blender_sig))
#end if
if show_info :
    sys.stderr.write("%s uses “%s” compression\n" % (infilename, in_compression.name))
#end if
if outfilename != None :
    if out_compression.wrap == None :
        raise RuntimeError \
          (
            "%s compression requested, but compression wrapper is not available" % out_compression.name
          )
    #end if
    outfile = out_compression.wrap(open(outfilename, "wb"), True)
    # infile.seek(0) # zstd doesn’t allow seeking backwards
    outfile.write(blender_sig) # instead, write out what I have already read
    while True :
        data = infile.read(io_blocksize)
        if len(data) == 0 :
            break
        outfile.write(data)
    #end while
    outfile.close()
#end if
infile.close()
